<?php

namespace App\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\NoResultException;
use \Doctrine\ORM\Query\Expr;
use App\Entity\Price;

/**
 * PriceRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PriceRepository extends EntityRepository
{
    public function getActiveAppartmentPrices()
    {
        $q = $this
            ->createQueryBuilder('p')
            ->select('p')
            ->where('p.type = 2 AND p.active = true')
            ->getQuery();

        $prices = null;
        try {
            $prices = $q->getResult();
        } catch (NoResultException $e) {

        }

        return $prices;
    }

    public function getActiveMiscellaneousPrices()
    {
        $q = $this
            ->createQueryBuilder('p')
            ->select('p')
            ->where('p.type = 1 AND p.active = true')
            ->getQuery();

        $prices = null;
        try {
            $prices = $q->getResult();
        } catch (NoResultException $e) {

        }

        return $prices;
    }
    
    /**
     * Find all prices that conflicts with the current one that are valid the whole year
     * @param Price $price
     * @return Price[]|null
     */
    public function findConflictingPricesWithoutPeriod(Price $price)
    {
        $q = $this->conflictingBaseQuery($price)
            /* select only proces where start and and is not set (valid for the whole year) */
            ->andWhere('p.seasonStart IS NULL and p.seasonEnd IS NULL')
            ->getQuery();

        $prices = null;
        try {
            $prices = $q->getResult();
        } catch (NoResultException $e) {

        }

        return $prices;
    }
    
    /**
     * Find all prices that conflicts with the current one based on a given season
     * @param Price $price
     * @return Price[]|null
     */
    public function findConflictingPricesWithPeriod(Price $price) {
        $q = $this->conflictingBaseQuery($price)
                /* find overlapping periods */
            ->andWhere("((p.seasonStart >= :start AND p.seasonEnd <= :end) OR"
                . "(p.seasonStart < :start AND p.seasonEnd >= :start) OR"
                . "(p.seasonStart <= :end AND p.seasonEnd > :end) OR"
                . "(p.seasonStart < :start AND p.seasonEnd > :end))")
            ->setParameter(":start", $price->getSeasonStart())
            ->setParameter(":end", $price->getSeasonEnd())
            ->getQuery();

        $prices = null;
        try {
            $prices = $q->getResult();
        } catch (NoResultException $e) {

        }

        return $prices;
    }
    
    /**
     * 
     * @param Price $price
     * @return \Doctrine\ORM\QueryBuilder
     */
    private function conflictingBaseQuery(Price $price) {
        $q = $this
            ->createQueryBuilder('p')
            ->select('p, ro')
            ->leftJoin('p.reservationOrigins', 'ro') 
                /* select only room type and active prices*/
            ->where('p.type = 2 AND p.active = true') 
                /* make sure that all room specific fields match */
            ->andWhere('p.numberOfBeds = :nob and p.numberOfPersons = :nop and p.minStay = :ms')   
                /* select only prices for the given reservation origin */
            ->andWhere(':ros MEMBER OF p.reservationOrigins')
                /* compare the weekdays whether there are conflicts, ignore all weekdays set to false and check only weekdays set to true */
            ->andWhere('((:ad = true AND p.allDays = true) OR (:mo = true AND p.monday = true) OR (:tu = true AND p.tuesday = true)'
                    . ' OR (:we = true AND p.wednesday = true) OR (:th = true AND p.thursday = true)  OR (:fr = true AND p.friday = true)'
                    . ' OR (:sa = true AND p.saturday = true) OR (:su = true AND p.sunday = true))')
            ->setParameter('nob', $price->getNumberOfBeds())
            ->setParameter('nop', $price->getNumberOfPersons())
            ->setParameter('ms', $price->getMinStay())
            ->setParameter('ros', $price->getReservationOrigins())
            ->setParameter('ad', $price->getAllDays())
            ->setParameter('mo', $price->getMonday())
            ->setParameter('tu', $price->getTuesday())
            ->setParameter('we', $price->getWednesday())
            ->setParameter('th', $price->getThursday())
            ->setParameter('fr', $price->getFriday())
            ->setParameter('sa', $price->getSaturday())
            ->setParameter('su', $price->getSunday());
        
        return $q;
    }
    
    public function findPrices(\App\Entity\Reservation $reservation, int $type, int $stays) {
        $q = $this
            ->createQueryBuilder('p');
        $q->select('p, ro')
                /* workaround to have prices with no period at the end of the result list */
            ->addSelect('CASE WHEN p.seasonStart IS NULL THEN 1 ELSE 0 END as HIDDEN start_is_null')
            ->join('p.reservationOrigins', 'ro', Expr\Join::WITH, $q->expr()->eq('ro.id', ':roid')) 
                /* select only room type and active prices*/
            ->where('p.type = 2 AND p.active = true') 
                /* make sure that all room specific fields match */
            ->andWhere('p.numberOfBeds = :nob and p.numberOfPersons = :nop and p.minStay <= :ms')  
            ->andWhere("(p.seasonStart IS NULL and p.seasonEnd IS NULL) or ((p.seasonStart >= :start AND p.seasonEnd <= :end) OR"
                . "(p.seasonStart < :start AND p.seasonEnd >= :start) OR"
                . "(p.seasonStart <= :end AND p.seasonEnd > :end) OR"
                . "(p.seasonStart < :start AND p.seasonEnd > :end))")
                /* select only prices for the given reservation origin */
            ->addOrderBy('start_is_null', 'ASC')
            ->addOrderBy('p.minStay', 'DESC')            
            ->setParameter('nob', $reservation->getAppartment()->getBedsMin())
            ->setParameter('nop', $reservation->getAppartment()->getBedsMax())
            ->setParameter('ms', $stays)
            ->setParameter(":start", $reservation->getStartDate())
            ->setParameter(":end", $reservation->getEndDate())
            ->setParameter('roid', $reservation->getReservationOrigin()->getId());            
        
        try {
            return $q->getQuery()->getResult();
        } catch (NoResultException $e) {
            return [];
        }

    }

    public function supportsClass($class)
    {
        return $this->getEntityName() === $class
        || is_subclass_of($class, $this->getEntityName());
    }
}
